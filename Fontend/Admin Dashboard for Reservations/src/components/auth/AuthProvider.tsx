import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { loginUser } from '../../Services/authService';

interface Admin {
  id: string;
  email: string;
  name: string;
  role: 'admin' | 'super_admin';
  createdAt: string;
}

interface AuthContextType {
  admin: Admin | null;
  token: string | null;
  login: (email: string, password: string) => Promise<{ success: boolean; error?: string }>;
  logout: () => void;
  isLoading: boolean;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

interface AuthProviderProps {
  children: ReactNode;
}

// Helper function to decode JWT (simple version for demo)
// TODO: Replace with proper JWT verification with your backend
function decodeJWT(token: string): Admin | null {
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    
    // Check if token is expired
    if (payload.exp && payload.exp * 1000 < Date.now()) {
      return null;
    }
    
    return {
      id: payload.id || payload.sub,
      email: payload.email,
      name: payload.name,
      role: payload.role,
      createdAt: payload.createdAt || new Date().toISOString()
    };
  } catch (error) {
    console.error('Error decoding JWT:', error);
    return null;
  }
}

// Helper function to create a mock JWT
// TODO: This should be generated by your backend
function createMockJWT(adminData: Admin): string {
  const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
  const payload = btoa(JSON.stringify({
    ...adminData,
    exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 7) // 7 days expiration
  }));
  const signature = btoa('mock-signature');
  
  return `${header}.${payload}.${signature}`;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [admin, setAdmin] = useState<Admin | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Check for saved JWT token
    const savedToken = localStorage.getItem('auth_token');
    if (savedToken) {
      const decoded = decodeJWT(savedToken);
      if (decoded) {
        setAdmin(decoded);
        setToken(savedToken);
      } else {
        // Token is invalid or expired
        localStorage.removeItem('auth_token');
      }
    }
    setIsLoading(false);
  }, []);

  const login = async (email: string, password: string) => {
    setIsLoading(true);
    
    // TODO: Replace with actual API call to your backend
    // Example: const response = await fetch('/api/auth/login', { method: 'POST', body: JSON.stringify({ email, password }) });
    try {
      // Mock login - replace with your backend API
      if (result.success && result.token && result.user) {
        setAdmin(result.user);
        const result = await loginUser(email, password);
        setIsLoading(false);
      }
        return { success: true, error: result.error };
    } catch (error) {
      setIsLoading(false);
      return { success: false, error: 'Error de conexiÃ³n' };
    }
  };

  const logout = () => {
    setAdmin(null);
    setToken(null);
    localStorage.removeItem('auth_token');
  };

  const value = {
    admin,
    token,
    login,
    logout,
    isLoading,
    isAuthenticated: !!token && !!admin
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}